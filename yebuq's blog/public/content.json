[{"title":"抓包神器charles","date":"2018-05-08T09:50:49.000Z","path":"2018/05/08/抓包神器charles/","text":"摘要： 好久没有更新博客了，还是不能懈怠啊。今天想分享一个很牛×的抓包工具——–charles。 正文: 众所周知，现在的app里面一般都会通过webview嵌入一些H5的前端页面。有些时候我们在本地开发环境跑的好好的代码，不知道怎么的在app的webkit里面就出了一些莫名其妙的问题。比如样式不对啊，js不跑呀什么的。但是让我们一个前端人员在app里面debug实在捉襟见肘啊。。完了还不能总麻烦人家移动端。那么这个时候你就拿到这个charles这个神器就ok了。 首先现在网上找到一个charles的资源下载安装，这个应该都不用我放图了把。。。然后呢，安装完毕，我们打开的界面是如下的： 然后我们首先点开左上角菜单栏的proxy，然后把windows proxy的对钩去掉。这个是抓我们pc端的一些请求的。我们想要的是移动端的，所以把pc端的过滤掉能找的更清楚。做完这些以后我们需要设置一下端口，还是点左上角菜单栏的proxy，然后选proxy setting，然后弹出如下窗口： 这里我们需要设置一下charles的端口号，实际上每次我们一打开charles，charles就会起一个本地的服务，然后我们所有的请求都是走这个这个服务，所以我们才能抓到这些请求。所以这里要设置一下服务的端口号。端口号要尽量避免与别的服务冲突，这里我用的端口号是9999。 接下来就需要我们的移动设备连上我们的charles的服务了，首先要保证我们的移动设备跟charles所在的机器是在同一个局域网。然后查看我们pc端的ip，右键开始菜单-运行-cmd打开dos窗口，然后输入ipconfig，然后打开如下的窗口： 我们要的是ipv4地址，然后记下这个我们的局域网ip地址，打开手机配置代理ip为这个ip，端口号为我们刚刚配置的端口号，比如我们的就是9999。我的是ios手机，所以拿ios来举个例：设置-无线局域网，找到我们所连的无线网，然后点网络名字右边那个小叹号，选最下面-配置代理，然后打开如下界面： 我的ip地址已经填上了，然后端口号是之前在charles里面设置的9999，然后点右上角存储。然后这时候charles第一次接入设备会有个提示，问题你允许设备接入么，这里我们点allow。然后就大功告成啦！如下图： 首先找到我们熟悉的抓包地址的域名，然后一层层点开，可以看到，包括请求服务器地址，请求状态请求头都可以看见，包括contents里面的返回数据我们都可以看见，如下图： 怎么样！是不是很赞！这样有的时候我怀疑我请求的js与css文件的服务器的地址不对不是测试服务器地址的话就可以用这个抓来看看。还有你抓到了一个游戏请求地址跟请求content的话，而正好这个请求又是个加金币的什么的。。那你重复发这个请求。。。。能懂吧？？哈哈哈。。。 当然charles还不只这个妙用，之前我们不是提过charles不是就相当与在你本地起了个服务吗？嗯对，现在只要跟你连接一个局域网的小伙伴都可以通过配置代理来访问你的本地文件。比如你想让设计小伙伴看你下你本地的页面，没问题，给他发你的ip端口号，完了你这边点一下allow，然后把你本地访问的链接给他就ok了，比如你起了个本地服务127.0.0.1就是你的页面主页，然后加上端口号127.0.0.1:9999设计们就可以访问到啦。最牛逼的我们通过host改的一些映射都会生效！当然这些延伸的有点深了。。不过你会用起来的时候真是很神器呀，哈哈。 好了，今天的分享就到这里了。欢迎大家踊跃留言~","tags":[{"name":"抓包","slug":"抓包","permalink":"https://yebuq.github.io/tags/抓包/"},{"name":"抓包charles","slug":"抓包charles","permalink":"https://yebuq.github.io/tags/抓包charles/"}]},{"title":"这个冬天不太冷","date":"2017-11-14T12:12:36.000Z","path":"2017/11/14/这个冬天不太冷/","text":"摘要: 一晃又十一月份了，数数一个月没有更新自己的小博客了。今天难得没有什么事情，晚上一个人在公司听着喜欢的歌，加着班，静静的写点东西，嗯。 正文: 苦尽甘来 还是从最近的工作说起吧。最近公司有了不小的变动。其它部门的人都搬到了东升科技园，而我们搬到了简理财的办公区，因为这个事情差点没气死。因为以前说好了我们所有部门都搬过去的，那样我上班多近啊，才三站地铁站。搬过去的话，爸爸都可以买个摩托车或者小车什么的，每天在五环外溜达开车上班，简直人生巅峰，不要太美好不好。有好几个同事房子都换完了，就为了离公司近点，结果领导突然通知我们“财富星球”部门的同事不搬家，还留在互联网金融中心。说是因为这个地标比较有标志性，所以要留一部分员工在这里，我们，就是被神选中的人（此处配上一个emoji微笑脸）。而且讲真的，这边每个工位的价格是东升的三倍多，想想也算还是平衡一点了。。。。 工位终于没有以前那么挤了，而我被老大安排的工位一开始还觉得不错，后来搬完了才知道，我的右手边坐的就是我们ceo（微笑脸），也是醉了。至今还没有在工位上面聊天打屁睡觉打过游戏。。嗯？当然，这是题外话。。。除了新搬了工位，我们公司最近还新招了很多人，什么市场啊、运营啊、商务啊、审计啊、产品啊甚至包括我们研发，各个部门的团队人员大概都扩张到了以前的两倍。而我，虽然才入职了5个月，却页不知不觉已经变成了我们公司的老员工。。变化是真滴大。而且由于人员的扩充，我们前端现在加上我也有了三个小伙伴了，比一开始刚入职的轻松了多了，也是终于松了一口气。不像一开始那样每天早十点晚十一二点，N个后台对接我一个前端人员了= =。但是话说回来轻松归轻松，手里的活也没断了，而且现在公司的各种业务不说全知道，但是也是了解个差不多，也算个互联网金融人了，各种活计也是做的得心应手，不像一开始刚来那会什么都不熟悉，喜欢这种感觉。。闲暇之余还顺带帮着研究研究前端改版的事情，感觉现在的短板就是对服务器什么的还没什么更多接触,所以了解了解这块挺好的。除了改版的事情，也终于有时间研究研究一些新的技术什么的，以此来提升自己，嗯。 除了这些之外，上个周六还参加了公司组织的新人野外训导训练，新入职的同事都一起到一个野外训练营做了一天的野外训导训练，感觉很好玩，也很有意义。认识了一些平常接触比较少的同事，互相知道了名字，还在游戏中互相说说笑笑，也算认识了新的一大票同事。当然最主要的还是少了不了认识了一堆妹子啦~哈哈~这句是玩笑玩笑~我可不是敢主动找不认识的妹子加微信的主。今天还刚参加完了公司福利的体检，好吧，轻度脂肪肝，牙结石，别的眼睛啊、内科啊、外科啊、胸腔啊、b超肾啊、脖子啊都还好。喜欢这种健康到一路过关斩将的感觉~ 最后放上一张“银小客梦想家训练营”中我们“飞鸿战队”的战队合影叭，嘿嘿。 因祸得福 最近生了场不大不小的病，后脑勺一节拇指大的地方头发没有了，秃了那种。最一开始，还是爱笑跟雅婧来我家玩的时候发现的，我自己都不知道。一开始我以为可能是上次剪头时候不小心给用推子给我推掉了，后来去剪头，那个剪头发的给我不是这么回事，说这是病，得治，给我吓个够呛。说这个常规名字叫“斑秃”，也叫“鬼剃头”，病因受精神影响比较多。我上网一查还真是这么回事。那个剪头的小哥用手机给我拍了一张照片，又用那个仪器给我拍了拍，能看到发根都没有头发了，而且后来发现有扩大的迹象，这真是把我吓坏了。一开始给我介绍他们的产品，说几个疗程见效大概要几个月，要几万块，给我说的一脑门子汗。 后来我决定还是先等等，病嘛肯定先去医院查，所以就去了北京协和医院，挂了号，第一次自己在北京挂号看病，挂号是真滴难挂，预约要预约到一星期以后，当天的号每天看都没有。后来我有一天早上5：30就起床，然后用app才抢到了一个皮肤科的号。然后请了一天病假，早上8点就到医院了，排队取号，等叫号差不多两个多小时，然后终于轮到我了大夫就给看了10分钟，说了一堆“别加班 别压力太大 别吃辣”的官话，然后随手开了一瓶喷在脑袋上的喷雾？我？？一脸懵逼。真的是生无可恋，感觉这也太随意了，然后我又起了个大早，重复循环早起挂号挂了个中医门诊，想着精神这个东西太玄乎了，肯定还是身体哪里出了问题。所以找个中医大夫把把脉，开点中药调理调理。。大夫摸脉的时候还真滴摸出了问题，肾虚、血淤、湿热。醉了。。还肾虚。。开了一个星期的中药，让医院帮我煎好寄过来。但是还没等药寄到呢，突然发现那个喷雾居然有效？掉头发的地方不在扩散了，而且有变小的痕迹！这可把我高兴坏了，但是拿回来的中药也有再吃，因为中医大夫说的症状我上网查了一下我确实都有，所以调理调理身体也挺好。这样头发也治好了，身体也调理好了，完美！！ 所以呢，现在头发也找到治疗方法了，身体也一点一点在调理好转，各位无需担心啦，嗯，哈哈哈哈，还真滴是吉人自有天相。这里没图了，生病贴什么图，真滴是。就发个我的帅照吧，哈哈哈哈 逼逼叨叨又没少说了,得了,最近的几个大事也就这样吧，嗯。说个小希冀吧，希望生活对我们好一点，对我的朋友们好一点，对错过的人好一点。最后还是上一张咋滴了萌图镇楼吧，嗯哼，嗯哼","tags":[{"name":"随笔","slug":"随笔","permalink":"https://yebuq.github.io/tags/随笔/"}]},{"title":"分享一个H5与app交互获取分享成功回调的案例","date":"2017-09-28T07:48:02.000Z","path":"2017/09/28/分享一个H5与app交互获取分享成功回调的案例/","text":"摘要: 最近忙的要死，因为赶上十一，今年的十一又和中秋重叠了（所以放那么多天假。。），所以公司一下主推了两个活动，这可真是把我忙坏了。。但是忙归忙，还是有一些小功能很有意思，这次就给大家主要分享一下跟app交互，获取用户分享成功的案例把。 正文：案例场景： 场景大概是这样的：公司做一个抽奖活动，抽奖次数呢是需要用户成功分享到微信或者朋友圈，这个时候才能获得一次抽奖机会。而我们的H5是在嵌在原生app里面的webview，分享的方法也是调用原生的方法，所以分享成功的回调其实是需要app端来传给我们的。那么好，问题来了，‘分享成功’这个要怎么判定呢？当时给出了以下几种方案： 1.第一个方案是给分享出的页面带上用户的id与token，用户点开页面与后台交互加一次抽奖次数。但是这种方案很快被产品否定了，因为这样的话分享前就需要用户登录才能给用户分享出去的页面带用户信息。 2.第二个方案是用户点击分享按钮就算分享成功，加一次分享次数，这种方法直接被我据了，这么low说真的我连做的的欲望都没有 3.第三个方案就是用户点击H5的分享按钮，然后弹出app原生的分享到微信还是qq的弹层，点击弹层里面的qq或者微信的图标才算分享成功。我觉得这个这个还不错，而且app端人员也提出了一个很让我惊喜的事情，就是他们可以手动调用我们的js方法，只要我们在浏览器里的控制台里面能直接调用的方法，app都可以调用。所以解决方案就是：点击微信或者qq的图标，app端就调用我们的js方法，方法内是我们H5告知后台分享成功的ajax请求。 光说不太直观，上个图把： 如上图，遮罩后面的页面是原生H5的，前面那个分享的弹层是原生app的，这样看就比较直观了把。 但是到最后逼逼叨叨了半天，还是选了第二种我觉得很low的方案，因为产品提出了我们忽略的一个重大问题：第二方案个需要app发版，用户不更新怎么办？不更新怎么办。。。。怎么办。。。此刻我的内心如下图。。。 卒。。。。 最后还有一个很偏门的问题分享给大家：你们之前有没有碰见过很奇葩的微信分享的icon莫名失效的，像下图： 我们都要上线了，突然发现这个问题，一只排查代码到晚上十一二点，后来发现不是代码问题？居然是分享的title跟content有问题。。。。这是微信的限制，如果分享内容有敏感词汇的话，图片上传就出问题了。。。这个问题简直神踏马。。。。。 好吧，这次分享内容就到这，没什么代码干货，纯逻辑，希望对各位同学有帮助。最后放上一张咋滴了囧图震楼，哈哈哈哈哈","tags":[{"name":"js","slug":"js","permalink":"https://yebuq.github.io/tags/js/"},{"name":"业务","slug":"业务","permalink":"https://yebuq.github.io/tags/业务/"}]},{"title":"关于vue-reource请求出错的坑","date":"2017-09-04T11:54:00.000Z","path":"2017/09/04/关于vue-reource请求出错的坑/","text":"摘要: 这次分享一个之前碰到的关于vue-resource post请求后台数据出错的坑，希望对大家有帮助，详细如下文。。。 正文: vue-resource与ajax还是有点不同的 分享一个之前碰到的关于vue-resource post请求后台数据出错的坑。在之前的开发工作中碰到了这么一个问题，在vue中使用vue-resource get请求一切正常，可是当使用post后台数据报错如下图： 然后使用ajax的post请求发现是没问题的？后来网上百度了半天才在这个http://www.jianshu.com/p/8d66070eac20简书一个大牛的帖子中找到问题所在。vue-resource默认的post的data是request payload的形式，而我们一般的ajax与form表单的话的data都是formdata的形式，所以跟后台请求的时候有些出入，才导致了数据出错。 解决方案有两种： 1.当然是麻烦后台同学改一下接口的兼容性啦； 2.这才是我今天重点分享的干货，就是在vue里面的main.js中添加如下的代码：123456Vue.config.productionTip = false;Vue.http.options.emulateJSON = true;Vue.http.options.emulateHTTP = true;Vue.http.options.headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'&#125;; 这样我们的vue-resource的data的格式就变成formdata啦，如下图所示： 像这样就大功告成啦！然后还要给大家分享一个自己范的很低级的错误。。。。我之前data的请求格式变回来了，然后数据请求也成功了，但是拿不到后台返回的数据（返回为空）是什么鬼？请看如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546this.$http.post('/app/mall/excharge', &#123; goodsId: _this.goodsInfo.id, code: _this.goodsInfo.code, number: _this.goodsInfo.number, userId: _this.userInfo.userId, token: _this.userInfo.token &#125;) .then((res) =&gt; &#123; _this.buyToggle = false; if (res.body.data.mall.status === 1) &#123; // code为1购买成功 const popConfig = &#123; msg: res.body.data.mall.msg, popShow: true, singleBtn: true, types: 'success' // buyReq是购买请求 &#125;; this.$emit('popToggle', popConfig); &#125; else if (res.body.data.mall.status === 2) &#123; // code为2商品已下架 const popConfig = &#123; msg: res.body.data.mall.msg, popShow: true, singleBtn: true, types: 'outUnder' // 商品已下架刷新按钮状态 &#125;; this.$emit('popToggle', popConfig); &#125; else if (res.body.data.mall.status === 3) &#123; // code为3购买库存不足 const popConfig = &#123; msg: res.body.data.mall.msg, popShow: true, singleBtn: true, types: 'reload' // 购买数量大于库存时需刷新购买页面 &#125;; this.$emit('popToggle', popConfig); &#125; else if (res.body.data.mall.status === -100) &#123; // 重复购买的时候不做提示 return false; &#125; else &#123; const popConfig = &#123; msg: res.body.data.mall.msg, popShow: true, singleBtn: true, types: 'false' // 购买失败直接返回文案 &#125;; this.$emit('popToggle', popConfig); &#125; _this.buyToggle = true; &#125;); 没错就是第8行，我不知道脑袋当时犯了什么抽抽，在es6的then方法前面换行了？？？而且es-lint居然还不报错有木有= =！！！然后then(res)里面的res接收到的返回值当时就是空啦。。。。。。所以小伙伴们千万不要学我犯这种低级的错误。嗯好了，今天分享就到这里了，希望有帮助的同学疯狂留言^_^。","tags":[{"name":"js","slug":"js","permalink":"https://yebuq.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://yebuq.github.io/tags/vue/"},{"name":"vue-resource","slug":"vue-resource","permalink":"https://yebuq.github.io/tags/vue-resource/"}]},{"title":"好久不见^_^","date":"2017-08-07T12:59:23.000Z","path":"2017/08/07/好久不见/","text":"摘要: 好久，好久没有更新一一下自己博客了!最近几个月真的发生了好多事情，多到自己都不知道该从哪里讲起。。。。嗯，有好的事情，也有不好的事情，有些可以讲的事情，还有些必须憋在心里没办法讲的事情。讲真有些事情憋着真的很难受。。哎。。。 正文: 换了家公司 嗯就先从自己换了公司这件事情说起吧。对，你们没有猜错，最近小跳了个槽，来到一个现在这个做p2p的公司，规模不小，几千人，已经上市了。公司福利也不错（社保公积金都百分缴，七险一金有木有），每天还有免费的零食跟水果啊，还有每个月一次的生日趴啊之类的。嗯，总之就是公司气氛很不错的说。重点是新公司的团队大家人都很好，什么后台的小伙伴啊，老大啊，部门老板啊，人都超级不错的有木有！虽然是比原来公司忙了点，说到这，我真的要吐槽一下了， 话说真的比原来忙了不是一点半点呀。。。。。基本每天加班到十点以后。。。上次一个大需求做完了还通了个宵。。。。早上才回家。然后大老板给我们研发发了个大红包，我抢了90多哈哈。。。还算是个安慰。。。。然后今天之所以有时间写东西就是因为我们今天又有一个大需求要上线。。嗯。。苦逼吧。。。我来这里快8个星期了。。一直都是我一个前端挑大梁。。后台无数个人对接我一个前端的说。。你们真的好意思嘛。。。老大说一直在给我招人一直在面试。。要招个高级带带我。结果，结果，结果来了个初级的妹子。。哎哟。。虽然我很喜欢妹子但是真的还是得来个高级的怎么也得成立个前端组，跟老大说了这个意思，好在老大支持我的想法，然后先从别的部门调来一个高手给我缓解压力，还有我们的初级妹子明天也来啦～～～感觉终于快解放了，哭死我了这个月。。。 嗯。公司的情况大概就介绍到这里吧。反正忙点是忙点，还算充实。通常你忙着忙着会发现：卧槽！今天周五，明天都放假了！哈哈！也挺好的。奥对了还有件大事，我们公司马上搬到东升科技园了，就在8月底，离我三站，超级近的有木有！我寻思着，可以买个拉轰的摩托车上班啦哈啊哈～～～～快点搬吧～～～～～下面贴上我近几天的打卡记录纪念一下 聚散离合 每次能比比的必少不了身边这堆损友。这么久了，大家都多少有点变化了。麟爷最终分了手，然后交了新女朋友（前后几乎尼玛没有缓冲期有木有！），老姨有了产品男，大侄最近浪的飞起。只剩下我跟胖子两个人苦苦在单身人海中徘徊。。。哎。。。好过分。。。所以觉得是时候浪一把了，该是忘了大哥的时候了，我爱过，爱的很深，付出很多，但是确实不是适合我的类型，那种跟谁都聊的飞起没玩够的确实不适合我，我投降，所以我退出。对不起没能一起看话剧，对不起没能一起看周杰伦的演唱会，对不起拉黑了你，对不起我会慢慢过去忘了你。我曾经给你说过的所有话都是认真的，现在这些也是，嗯。哎，不开心的不说了，字打在这里她也看不到，其实没啥卵用。。说点高兴的，老姨升了职，大侄找了新工作涨了工资，胖子满了一年也涨了一千块，我这次跳槽当然也涨工资啦（涨多少保密哈哈！），麟爷技术有了长足的发展，大家都在潜移默变，都在慢慢成长。希望我们几年以后甚至十几年几十年以后都还能在一起聚聚，说说我们曾经傻逼的日子。如果你们把我当回事的话，你们的婚礼我一定一个不缺场，嗯，这是一个期望，当然我的你们更是一个不能缺。 朋友们就比比到这吧，虽然嘴上说着烦你们浪的飞起不会再带你们玩了，但是其实心里还是希望你们好的，有事情的话肯定义不容辞，嗯。最后放上一张我自认为是我们巅峰时期的照片吧^_^哦对忘了说张图大美女，在我们这堆程序猿（媛）里，考研上学的雅静简直就是个另类呀哈哈，希望越变越美布拉布拉。。。。下面，请看照片！陪伴了我三个多月的新家庭成员 该是给大家隆重介绍我家新成员：咋滴了 的时候了o(^▽^)o~~4.14出生的咋地了居然跟我一个生日。。。。这踏马简直就为我而生的小猫啊。。。这个小家伙是我在5.1抱回来的，第一次见面都就被这个家伙的颜值深深的折服了。。。真的好萌好可爱啊啊啊，在网友的家里一眼就看中了。。最终花了我1500大洋在跨越了一个北京城从南到北的距离后，终于把这个家伙接回家啦！ 刚进家门的时候还只是怕怕的蹲在地上，缩成一团怕怕的一直盯着我看，在不到一个小时以后，已经开始床上床下蹦个没完没了了= =。 刚抱回家的时候，总盯着我一直叫个不停，出于礼貌我就一直回答他：咋滴啦!然后，然后你们应该知道它的名字是怎么来的吧= =数数，咋地了现在陪我居然超过3个月了，时间是过的真快啊！一开始早上一顿猫粮，晚上一顿奶，夜宵是营养膏，是真的不敢怠慢。后来满了3个月奶给断了一阵，发现这个家伙我一喝牛奶就馋的跟什么似的老跟我抢= =得，看来药不能停，奶不能断啊，还是得继续供着。咋滴了在一堆爸爸妈妈的万千宠爱下到现在也已经茁壮长成一直大猫了（比刚进家那会真的大了不止一点半点。。），上个月14号带他去医院打了第一针驱虫镇。还记得当时一进宠物医院就被围观了，大家都说好可爱好漂亮啊！我这当爸的真的是无比自豪啊！哈哈！嗯，以前这家伙的饭量都是我在控制，一天倒固定的量。后来前一阵子我懒了，早上出门之前直接给倒了满满一盆猫粮，然后，然后几天发现这个家伙肚子真的特么大的吓人啊！身材比例都失调了！为了继续让他保持身材，为了继续能让他给爸爸招来小姐姐。。我决心给他减肥！继续以前一样给他固定量的猫粮，不能再多吃了，特喵的你胖成猪你看我还要不要你。 这个月14号得带他去打第二针了，嗯，爸爸希望你能茁壮成长，能陪我好久好久。。。。。下面的话就放张咋滴了洗澡的黑人图吧哈哈o(^▽^)o但是讲真，我们家咋地了真的洗澡的时候都贼帅，除了有的时候趴着的姿势贼逗比外没别的毛病。。。话不多说，上图： 感觉如果咋滴了看见我发的照片一定绝交了。。。哈哈哈哈哈哈。哎哟，行了，比比叨叨的不知不觉码了这么多字了，总之希望自己生活会慢慢更好，我知道人都是想看人家不好，以后我多码点不高兴的给你们看o.0，嗯。目前已经12点了，身边的同志们还在激烈战斗，一张图片结束今天逼到吧，希望忘了没必要的人，希望能追上我喜欢的人！","tags":[{"name":"啦啦啦","slug":"啦啦啦","permalink":"https://yebuq.github.io/tags/啦啦啦/"},{"name":"小心情","slug":"小心情","permalink":"https://yebuq.github.io/tags/小心情/"}]},{"title":"移动端不同像素比的贴图与边框问题","date":"2017-06-01T02:27:18.000Z","path":"2017/06/01/移动端不同像素比的贴图与边框问题/","text":"摘要: 开发过移动端的都知道，移动端的设备像素分为物理像素跟设备像素，而且不同型号的设备的物理像素的还不一样，比如iphone6的物理像素就是设备像素的两倍，而iphone6Plus的物理像素则是设备像素的三倍。这就造成了我们在css中所使用的到的px这种相对单位的在移动端的浏览器解析中有了不一样的表现。那为了让我们的项目在不同设备中的表现区别不大，就需要我们做一些工作了。下面我来为大家介绍几个在移动端开发中我们经常遇到的问题跟几角方案。 正文: 添加一像素边框 在css样式中我们经常会遇见需要给一个div下面加上1px的底部边框的需求。这个通常我们只需要在给div加上一个border-bottom 1px就可以了。但是在移动端中一个1px就出问题了，你会发现在手机端上面这个1px会比平常要宽。这就是因为设备物理像素跟设备像素比的问题了。比如iphone6下这个1px会变成2px，而iphone6Plus下这个1px则会变成3px。那么我们可以通过@media给不同的设备写一下兼容。 123456789101112131415161718192021222324252627282930.div&#123; position: relative;&#125;.div:after&#123; display: block; position: absolute; left: 0; top: 0; width: 100%; content:''; border-top:1px solid #000;&#125; @media(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5)&#123; .div:after transform: scaleY(0.7); -webkit-transform: scaleY(0.7); &#125; &#125; @media(-webkit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2)&#123; .div:after&#123; transform: scaleY(0.5); -webkit-transform: scaleY(0.5); &#125; &#125; @media(-webkit-min-device-pixel-ratio:3),(min-device-pixel-ratio:3)&#123; .div:after&#123; transform: scaleY(0.3); -webkit-transform: scaleY(0.3); &#125;&#125; 这样我们给需要加border的元素一个伪类并给这个伪类绝对定位让他贴附在该元素的底部，然后给这个伪类一个border-top 1px，然后分别在像素比为1.5的设备下让线条缩放0.7倍，像素比为2.0的设备下缩放0.5倍，像素比为3.0的设备下缩放0.3倍，这样换算下来就都差不多是1px的样子了。 图片的兼容不知道大家有过这样的经历没有，一半在移动端开发的时候ui给我们的设计图一般都会两套不同的大小。比如一个图片叫picture@2x.png，那么相对应的一定就会有一个picture@3x.png，有没有想过这是为什么呢？其实这也是为了适配我们在不同像素比的设备，在不同像素比的设备中使用不同大小的图标以防图片虚化，这是兼容的图片的一个常用思路。12345678910111213.span&#123; display:inline-block; width:30px; height:30px; background-image: url(picture@2x.png); background-size: 30px; background-repeat: no-repeat;&#125;@media (-webkit-min-device-pixel-ratio:3),(min-device-pixel-ratio:3)&#123; .span&#123; background-image: url(picture@3x.png); &#125;&#125; 这里还有一个需要我们注意的地方，我们知道我们为了网站优化减少http请求次数，通常都把一些图标集合起来做成一个大的精灵图，这时候可能需要我们改变的就是图片的位置background-position。其实除了这种方法我们还可以把这些图片转成base64格式，让其已代码的形式存在于css中，这样既减少了http请求次数，还方便我们的项目构造，真的很方便实用，像vue的脚手架工具vue-cli就会自动为我们把一些小图片打包到css当中，非常方便，当然这些都是题外话了。 还有今天是儿童节，祝大家永远18睡,还有哦，文章开头的图片是我家新成员 咋地了，哈哈~~下次会专门更新篇博客来重大介绍一下我家新成员o(^▽^)o~~","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"https://yebuq.github.io/tags/移动端/"},{"name":"css","slug":"css","permalink":"https://yebuq.github.io/tags/css/"}]},{"title":"在node.js下用mongoose简单的操作mongoDB面向文档","date":"2017-05-02T02:56:47.000Z","path":"2017/05/02/在node-js下用mongoose简单的操作mongoDB面向文档/","text":"摘要: MongoDB是一个面向文档的数据库，它非常适合Node.js应用以及云端部署，因为MySql以及PostgreSql是根据固定的结构设计将数据存储在不同的表之中，而MongoDB可以将任意类型的文档数据储存到集合之中，这也是MongoDB最有意思的特性之一。所以今天就安利一波如何用node.js操作MongoDB数据库。 正文: 要在node.js中操作MongoDB，我们首先要选择一个方便我们操作的node的插件，比较常用的插件有两种，分别是’mongodb’与’mongoose’。这里我推荐使用mongoose，因为他是根据mongodb封装的一个插件，使用起来更方便，操作起来也更简洁。 首先我们要在node中安装mongoose，在跟git bash中输入1npm install mongoose --save 当然如果你安装了淘宝镜像，那么使用cnpm更好。接下来我们在node.js项目中新建一个server.js文件，然后在其中输入依赖：1var mongoose = require('mongoose'); 这样我们就引入了mongoose这个插件，接下来我们需要利用这个插件来连接数据库1mongoose.connect('mongodb://localhost:my-website') 这里注意了，’my-website’是你在MongoDB中的数据库的名称，如果数据库中没有这个名字的话，那么MongoDB会自动新建一个名字为’my-website’的数据库并连接。然后我们建立一个数据模型，这个模型建立可以在文件任意位置定义，无所谓Mongoose是否已经与数据库连接,这里我们模拟建立一个用户注册的模型，包含用户的名字，信箱，以及密码信息。123456var Schema = mongoose.Schema;var user = mongoose.model('User',new Schema(&#123; first:String, last:String, email:&#123;type:String, unique:true, password:&#123;type:String, index:true&#125;&#125;&#125;)) 这里我们设置了所有的字段类型都是string类型，email的字段我们设置为唯一不可重复。然后添加新的数据到MongoDB,我们调用save的方法：12345var user = new User(req.body.user).save(function (err) &#123; if(err) return next(err); console.log(user); //成功存入后的方法; &#125;) 这里要注意我们传的参数req.body.user里面的字段要与我们创建的模型User里面的字段名字相匹配。接下来是查询的方法findOne：1234567User.findOne(&#123;email:req.body.user.email,password:req.body.user.password&#125;,function (err, doc) &#123; if(err) throw err; if(!doc) return res.send(\"&lt;p&gt;user is not found! please go back an try again&lt;/p&gt;\") console.log(doc); req.session.loggedIn = doc._id; res.redirect('/'); &#125;) 如果查询成功，函数会成功返回一个doc，里面包含了我们查询到的相关信息，这里我要重点给大家介绍一下doc_id这个东西，doc_id是在存储的时候MongoDB自动创建的唯一标识id，方便于我们操作，有一点要注意这个ID是ObjectID类型的。具体查询方法如下：123456User.findById(req.session.loggedIn , function (err, doc) &#123; if(err) return next(err) console.log(doc); app.locals=&#123;me:doc&#125;; next(); &#125;) 这里req.session.loggedIn就是我们存储的doc_id，根据这个id查询出的信息都是唯一的。 下面给大家分享一段我一个模拟登陆注册的server.js的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110var express = require('express'), bodyParer = require('body-parser'), jade = require('jade'), cookieParser = require('cookie-parser'), mongodb = require('mongodb'), http = require('http'), session = require('express-session'), ObjectID = require('mongodb').ObjectID, mongoose = require('mongoose');/** * 创建中间件以及一些中间件需要用到的插件 */var app = express();app.use(bodyParer.urlencoded(&#123;extended:true&#125;));app.use(cookieParser())app.use(session(&#123; resave:false, saveUninitialized:false, secret: 'keyboard cat'&#125;))/** * 定义模板引擎 */app.set(\"view engine\",\"jade\");app.set('views',\"./views\")/** * 连接数据库 */mongoose.connect('mongodb://localhost/my-website')/** * 定义模板 */var Schema = mongoose.Schema;var User = mongoose.model('user',new Schema(&#123; first:String, last:String, email:&#123;type:String,unique:true&#125;, password:&#123;type:String,index:true&#125;&#125;))/** * 登陆状态的验证的通用路由 */app.use(function (req, res, next) &#123; if(req.session.loggedIn)&#123; res.locals = &#123;authenticated:true&#125; console.log(req.session.loggedIn) User.findById(req.session.loggedIn , function (err, doc) &#123; if(err) return next(err) console.log(doc); app.locals=&#123;me:doc&#125;; next(); &#125;) &#125; else&#123; app.locals = &#123;authenticated:false&#125; next(); &#125;&#125;)/** * 主页路由 */app.get('/',function (req, res, next) &#123; res.render('index');&#125;)app.get('/login/:signupEmail',function (req, res, next) &#123; //这里允许主页接收一个参数 res.render('login',&#123;signupEmail:req.params.signupEmail&#125;)&#125;)/** * 登陆路由模块 */app.get('/login/',function (req, res, next) &#123; res.render('login')&#125;)app.post('/login',function (req, res,next) &#123; User.findOne(&#123;email:req.body.user.email,password:req.body.user.password&#125;,function (err, doc) &#123;//验证登陆账号密码 if(err) throw err; if(!doc) return res.send(\"&lt;p&gt;user is not found! please go back an try again&lt;/p&gt;\") console.log(doc); req.session.loggedIn = doc._id; res.redirect('/'); &#125;)&#125;)/** * 注册路由模块 */app.get('/signup',function (req, res) &#123; res.render('signup')&#125;)app.post('/signup',function (req, res) &#123; console.log(req.body); var user = new User(req.body.user).save(function (err) &#123;//注册信息保存到MongoDB数据库 if(err) return next(err); console.log(user); res.redirect('/login/' + req.body.user.email); &#125;)&#125;)/** * 登出操作 */app.get('/logout',function (req, res) &#123; req.session.loggedIn = null; res.redirect('/')&#125;)http.createServer(app).listen(3000); 希望我的分享对大家有帮助哦o(^▽^)o本文原创欢迎转载~~~~","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://yebuq.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://yebuq.github.io/tags/node-js/"}]},{"title":"关于js复杂类型和构造函数的一点小知识","date":"2017-04-18T02:21:45.000Z","path":"2017/04/18/关于构造函数的一点小知识/","text":"摘要: javascript脚本语言在进入v8以后可以说是无所不能，而构造函数更可以说是前端代码逼格化灰常重要的技能，可以大大减少代码的重复性，让我们的js代码看起来更加简洁易懂。然而，逼格越高的东西往往也越不容易理解，所以今天在这里给大家介绍一些关于js的复杂类型和构造函数的一些入门知识。 正文: 类型 javascript类型可以简单的分为两组：基本类型和复杂类型。访问基本类型，访问的是值。而访问复杂类型，访问的是值的引用，或者说是对指针的访问。 ·基本类型包括number，boolean，string，null，undefined; ·复杂类型包括array，object，function; 如下述例子：12345678910111213//基本类型var a = 5;var b = a;b = 6;a;//结果为5b;//结果为6//复杂类型var a = ['hello','world'];var b = a;b[0] = 'bye';a[0];//结果为'bye'b[0];//结果为'bye' THIS,FUNCTION#CALL,FUNCTION#APPLY 在浏览器对象中，window就是全局对象，而下面的代码中，this则指向全局对象：123function a ()&#123; window == this; //true&#125; .call和.apply可以改变this引用的对象1234function a ()&#123; this.a == \"b\"; //true&#125;a.call(&#123;a:\"b\"&#125;); 而call和apply的区别在于，call接收一个参数列表，而apply接收一个参数数组123456function a (b,c)&#123; b == 'first' //true; c == 'second' //true;&#125;a.call(&#123;a:'b'&#125;,first,second);a.apply(&#123;a:'b'&#125;,[first,second]) 构造与继承 javascript中没有类关键词。所以类的概念我们只能通过函数来定义：1function Animal()&#123;&#125; 可以通过函数的prototype属性来完成对所有Animal的实例定义函数123Animal.prototype.eat = function(food)&#123; //eat method&#125; 而在此时，函数内部this指向的就不是全局对象window了，而是通过Animal实例出的对象12345678function Animal(name)&#123; this.name = name;&#125;Animal.prototype.getName = function()&#123; console.log(this.name);&#125;var animal = new Animal(\"cat\");animal.getName == \"cat\";//true; 万幸在v8发布以后我们有了proto属性，它使的定义继承链变得更加更加容易：12345678910function Animal()&#123;&#125;Animal.prototype.cname = \"cat\";function Ferret()&#123;&#125;Ferret.prototype.__proto__ = Animal.prototype;console.log(Animal.prototype.cname); //结果为catconsole.log(Ferret.prototype.__proto__.cname);//结果为cat 这样，Animal中的prototype中的属性就全部保存在Animal里面了。然而大家要记住，proto这个属性就像复杂类型一样只是指向构造器的prototype，访问的并不是值，更像是指针的引用。所以当我们改变proto里面的属性以后，就相当于改变了构造器里面的prototype。我们用下面一个例子来引申：123456789101112131415161718192021222324function fnTest(name)&#123; this.name = name; this.sayName = function()&#123; console.log(this.name); &#125;&#125;fnTest.prototype.showName=function()&#123; console.log(this.name + \"1111\");&#125;;var a = new fnTest(\"dog\");var b = new fnTest(\"cat\");console.log(b);b.sayName = function () &#123; console.log(this.name + \"3333\")&#125;;b.__proto__.showName = function () &#123; console.log(this.name + \"2222\")&#125;;a.sayName(); //结果为dogb.sayName(); //结果cat3333a.showName(); //结果dog2222b.showName(); //结果cat2222","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yebuq.github.io/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://yebuq.github.io/tags/构造函数/"}]},{"title":"手把手教你如何用node.js创建一个聊天室","date":"2017-04-06T01:55:28.000Z","path":"2017/04/06/手把手教你如何用node-js创建一个聊天室/","text":"摘要: node.js无疑是当下最火的前端构建后台的的工具，包括一些gulp，webpack，grunt，都是建立在node.js之上的。node的强大可以说可以帮前端光用JS就可以实现一些。今天就分享一波如何用node.js里面最简单的一些module实现一个简单的聊天室 正文: 话不多说，先上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var net = require(\"net\"); //应用模块var userCount = 0; //记录当前用户数量var users = &#123;&#125;; //记录用户信息var server = net.createServer(function(c)&#123; var nickname = \"\"; //创建一个变量，用于保存新建用户名 userCount ++; var message =''; //创建一个空字符串用于接收用户输入的信息片段 c.setEncoding(\"utf8\"); //设置新建连接的编码格式为utf-8 c.on(\"data\",function(data)&#123; //绑定一个data事件，用于监听客户端的输入操作 if(data !=\"\\r\\n\")&#123; //判定如果输入的不是回车，则把输入的信息片段拼接起来 message += data; return; &#125; else&#123; if(!nickname)&#123; //判断如果此链接不存在昵称，则是首次联结聊天室 if(users[message]) //如果用户输入的昵称已经存在，则重新输入 &#123; c.write(\"the nick your putin had already exist , please again : \\r\\n\"); return; &#125; else&#123; for(var i in users)&#123; users[i].write( message + \" has already connected in ~\\r\\n\"); //新用户链接，给其他用户发送公告 &#125; nickname = message; //保存用户输入的昵称 users[message] = c; //把每个新创建的连接添加到用户群组中 userCount ++; //用户数加1 var curUsers = Object.keys(users); console.log(\"current users : \" + curUsers); c.write(\"alright , your name is :\" + message + \"\\r\\n\"); c.write(\"current users : \" + curUsers +\"\\r\\n\"); c.write(\"please input your message:\\r\\n\"); &#125; &#125; else&#123; c.write(\"your says:\" + message +\"\\r\\n\"); //在当前客户端打印你输入的信息 for(var i in users)&#123; if (i != nickname)&#123; users[i].write(nickname + \" says : \" + message +\"\\r\\n\"); //广播当前连接发送的信息 &#125; &#125; &#125; message = \"\"; return; &#125; &#125;); c.on(\"close\",function () &#123; //连接关闭删除用户 delete users[nickname]; userCount --; //用户数量减减 console.log(nickname + \" quite !\"); //服务端打印出退出的用户 &#125;); c.write(\"hello~ please input your nickname and then press Enter: \\r\\n\");&#125;).listen(3000,function()&#123; //监听端口3000 console.log(\"server bound !\");&#125;); 怎么安装node就不详细介绍了，自己百度下吧。然后新建项目，创建一个index.js，然后把上述代码复制进去，然后再doc界面输入node index启动服务，这样服务端就大功告成了。然后客户端用windows跟mac都自带有的telnet来测试（这里需要注意，一般电脑上的telnet进程是默认关闭的，可以百度一下先把这个服务打开），然后再运行用输入telnet 127.0.0.1:3000，就能连接到我们的服务端了。 看下代码逻辑：首先我们这里只用到了一个node里面叫”net”的模块，这个模块跟”http”模块相似，都可以用.createServer来创建服务，然后每个createServer里面接收的参数（c）就是我们可以操作的连接，每次新进来一个用户你就可以理解为新创建了一个c变量。然后我们监听每个连接的数据传送就是监听c的data事件，监听每个连接的关闭事件，就是监听c的close事件，连接的编码格式就是c.setEncoding(“utf8”)。这样讲就非常好理解了。 我们这里用了users[message] = c用了这样一句话把每个新建连接保存在一个对象之中，然后每次给所有用户广播消息的时候只需一个循环给对象里的每个连接都发送一次当前客户端发送的消息，就可以啦！ 但是这里有一个点非常需要注意，我们监听c的data事件，是每次有变动就触发的。意思就是 if(data !=”\\r\\n”) 如果你不主动判断一下是否输入了回车字符的话，每次你输入一个字母，data事件就给我们返回一个字母，更像一种流传送的形式。所以我们这里用回车来截断一下，判定每次用户输入回车为一段完整字符串的输入，不然的话就把字符片段与之前的片段拼接在一块，这样每次看到的就是一段完整的话了。 好了，大概介绍这么多，有什么不懂的可以给我留言啦。","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"node.js","slug":"node-js","permalink":"https://yebuq.github.io/tags/node-js/"},{"name":"聊天室","slug":"聊天室","permalink":"https://yebuq.github.io/tags/聊天室/"}]},{"title":"关于ajax如何提交照片等file类型的文件","date":"2017-03-29T02:54:50.000Z","path":"2017/03/29/关于ajax如何提交照片等file类型的文件/","text":"摘要: 好久没有更新博文了。。。感觉是时候分享一波小技术了o(^▽^)o，嗯今天就分享一个关于项目中如何用ajax上传图片的小知识。。你准备好了吗。。。？？ 正文： 问题是这样的，项目里遇到一个表格里添加一行的操作，所以这个没有办法用表单提交，别的都好好说，用ajax传一个json字符串给后台就好了，但是这个图片就没办法跟json字符串一块传过去了。所以网上找到了这个方法，觉得写的很好很常用，所以还是写在自己的博客里方便分享。话不多说直接上代码：1234567891011121314var formData = new FormData();formData.append('file', $('#up_img_add')[0].files[0]);$.ajax(&#123; url: \"../../rest/group/upload\", method: \"POST\", async: false, contentType: false, processData: false, //必须false才会自动加上正确的Content-Type, data: formData, success: function (data) &#123; console.log(data); equipGroup.image = data; &#125;&#125;); 这里首先创建一个FormData()对象，一开始不知道，百度一下才知道FormData()这个对象真的是个好东西，可以保存的东西有名为”username”，”accountnum”，”userfile” 以及 “webmasterfile” 的字段名，字段 “userfile” 和 “webmasterfile” 的值都包含了一个文件，”accountnum” 的数字被自动转换为字符，”webmasterfile” 字段的值不是一个字符串,还是一个 Blob 对象。例：123456789101112var oMyForm = new FormData();oMyForm.append(\"username\", \"Groucho\");oMyForm.append(\"accountnum\", 123456); // 数字123456被立即转换成字符串\"123456\"// fileInputElement中已经包含了用户所选择的文件oMyForm.append(\"userfile\", fileInputElement.files[0]);var oFileBody = \"&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;\"; // Blob对象包含的文件内容var oBlob = new Blob([oFileBody], &#123; type: \"text/xml\"&#125;);oMyForm.append(\"webmasterfile\", oBlob); 用 formData.append(‘file’, $(‘#up_img_add’)[0].files[0])这个给创建的formData对象插入你要上传的input标签的files值，然后就可以用ajax上传啦！但是上传的时候要注意两点： 1.contentType: false, processData: false, 这两句话一定要加上，不然jquery的ajax会默认给你加上错误的头部type类型。 2.data这个字段是不需要定义的，加上之后会发生意想不到的错误。 然后后台接收到图片以后会保存在一个目录下面，然后把这个目录的url地址返回给我们，我们就可以调用啦！大功告成~","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"文件上传","slug":"文件上传","permalink":"https://yebuq.github.io/tags/文件上传/"},{"name":"ajax","slug":"ajax","permalink":"https://yebuq.github.io/tags/ajax/"}]},{"title":"啦啦啦。。略略略~~","date":"2017-03-08T02:59:28.000Z","path":"2017/03/08/啦啦啦。。略略略/","text":"摘要： 好几天没有更新博客了，因为这几天不愉快的事情太多了，都赶一起了。直到今天才感觉好点，就随便写点生活的上的事情吧。 正文： 销声匿迹了好几天，都是在静静的潜修，修的的不是别的是心态，因为最近是真的特么狠烦…先是干了件二逼事，然后就是周末吃坏了东西上吐下泻连带发烧了好几天，再然后就是面试被虐，心情爆炸到了极点…我曾经发过这样一条朋友圈：烦躁时不张牙舞爪，高兴时不得意忘形。不得意忘形我是没咋做到。。但是不张牙舞爪还是必须的，因为你一时的张牙舞爪，很可能就伤了你身边的朋友一辈子，而且越亲近的越是。所以每次自己烦的时候都觉得还是尽量不要跟别人有什么交互的好，喜欢一个人待会好先把自己心情收拾好，才能在别人面前显的强大哈哈。 直到今天肠胃总算是好点了，烧也退了，终于有胃口吃东西了伴随着心情也嗨皮起来了。首先得谢谢各位小伙伴的关心（总感觉这句话有点像谢谢党和政府一样强行插入…），在偌大的北京，起码不好了还有人问问，感觉还是不错了，哈哈o(^▽^)o…其次呢，其次我给忘了…本来今天上午还构思的好好的，但是写着写着突然工作上来活了，忙着忙着就把已经构思好的都忘了，有点尴尬啊… 但是无所谓，忘了就忘了吧，就说说自己吧。可能是我最近太饥渴的缘故最近公司的财务美女跟一个小老姨总想着要给我介绍美女，额，这个东西我是真的没有经历过互相介绍那种的，感觉，两个人不应该是为了在一起而玩的熟了，而是玩的熟了才应该在一起了，所以我觉得我还是喜欢那种两个人水到渠成的感觉。而且，重点是我家里也没有人催，我也不着急，大不了多吃几把狗粮，还可以趁着自己单着把自己变得更优秀（不管你们信不信..我是信了..呵呵..）。 写着写着又没得写了，突然想起来胖子说的一句话：“你不跟那sb说话他也不跟你喷”，哈哈哈哈哈，真的每次想起来这句话我都笑到掉眼泪。因为他们家合租的住了一个男的，这个男的我俩见过之后一致认为没有比他再能装x的了，然后我之后再没怎么去过胖子家，然后各种同情胖子需要跟这种人住一起。然后某一天我继续同情他的时候，他就说了这句话，哈哈哈哈。简直心酸带着无奈带着坚强啊！五味陈杂有木有！哎哟，不行了，再让我笑会再写….我感觉这个梗，撑起了我今年的笑点… 今天朋友圈还看见小仙女呲牙咧嘴的自拍照了，顺手点了个赞。我最近心情不好，怕发的话也都是矫情的话，所以朋友圈也还是不要发了，忍忍吧。包括以后，我都不想做一个矫情的人，在这立个flag，嗯。对了说到这，还想到说了最近想养只小猫(知道我为什么贴这么多猫的照片了吧…)。想一想，你在家敲着敲着代码，一只小猫跳到桌子上在你键盘上乱踩几下是得多有爱…嗯，一起养只小猫，可以的。本来是想着领养一只小猫的，但是打了两个百度的领养中心电话，发现都换人了，所以可能还得想别的办法。想着最好从小养一只，有感情。而且说好的一人一半啊，到时候不许特么耍赖啊@内个人 还有好多好多琐事，比如：上个月请两天假导致这个月工资少了1000多块啊，电动牙刷坏了发现自己不会刷牙了导致我又花了好几百块买了个新的啊，还有前两天终于入手了一只姑获鸟啊（自此以后抽到的都特么是r），奥对说到这突然想起来某人给寄的巧克力也到了，谢谢，很开心，还有周末要跟一对吃饭又特么要吃狗粮了啊…嗯，就这么多吧，反正就是希望自己好，还有，期待小猫的到来~o(^_^)o","tags":[{"name":"生活","slug":"生活","permalink":"https://yebuq.github.io/tags/生活/"},{"name":"日常","slug":"日常","permalink":"https://yebuq.github.io/tags/日常/"}]},{"title":"eclipse配置项目可以被跨域访问:Access-Control-Allow-Origin:*","date":"2017-03-01T02:20:39.000Z","path":"2017/03/01/eclipse配置项目可以被跨域访问-Access-Control-Allow-Origin/","text":"摘要: 这篇文章旨在分享一下eclipse如何配置项目可以被跨域访问到。因为网上看了很多，坑也踩了不少，而且身为一个前端的小白，有些地方忽略的我一头雾水有木有= =，所以我会图本并茂的讲解一下，大神请忽略= = 正文: 这篇文章旨在分享一下eclipse如何配置项目可以被跨域访问到。因为网上看了很多，坑也踩了不少，而且身为一个前端的小白，有些地方忽略的我一头雾水有木有= =，所以我会图本并茂的讲解一下，大神请忽略= = 百度到的方法大多是教给我们利用cors，或者是在java里新建一个filter类，然后配置web.xml配置里新加一堆标签，可是我想说身为一个小白的我，表示怎么创建这个类，在哪创建都不知道啊。。后来研究了半天，又百度了不少，才算是弄明白一整套流程，也是最简单的方法： 1.编写拦截器代码，在项目目录下src/default package/下新建一个类CrossOriginFilter，实现Filter接口，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.digdata.swustoj.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;/** * * @author wwhhf * @since 2016年5月30日 * @comment 跨域过滤器 */public class CrossOriginFilter implements Filter &#123; private FilterConfig config = null; @Override public void init(FilterConfig config) throws ServletException &#123; this.config = config; &#125; @Override public void destroy() &#123; this.config = null; &#125; /** * * @author wwhhf * @since 2016/5/30 * @comment 跨域的设置 */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse httpResponse = (HttpServletResponse) response; // 表明它允许\"http://xxx\"发起跨域请求 httpResponse.setHeader(\"Access-Control-Allow-Origin\", config.getInitParameter(\"AccessControlAllowOrigin\")); // 表明在xxx秒内，不需要再发送预检验请求，可以缓存该结果 httpResponse.setHeader(\"Access-Control-Allow-Methods\", config.getInitParameter(\"AccessControlAllowMethods\")); // 表明它允许xxx的外域请求 httpResponse.setHeader(\"Access-Control-Max-Age\", config.getInitParameter(\"AccessControlMaxAge\")); // 表明它允许跨域请求包含xxx头 httpResponse.setHeader(\"Access-Control-Allow-Headers\", config.getInitParameter(\"AccessControlAllowHeaders\")); chain.doFilter(request, response); &#125;&#125; 2.WEB-INF/lib下找到web.xml，添加如下代码（有的人项目下会没有自动生成web.xml这个文件，请参考http://jingyan.baidu.com/article/90808022c495d9fd91c80f15.html）:123456789101112131415161718192021222324&lt;filter&gt; &lt;filter-name&gt;CrossOrigin&lt;/filter-name&gt; &lt;filter-class&gt;org.digdata.swustoj.filter.CrossOriginFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;AccessControlAllowOrigin&lt;/param-name&gt; &lt;param-value&gt;http://localhost:63342&lt;/param-value&gt;//这个value是要换成你的请求网址，如果是*为可以被所有网址跨域请求 &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AccessControlAllowMethods&lt;/param-name&gt; &lt;param-value&gt;POST, GET, DELETE, PUT&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AccessControlMaxAge&lt;/param-name&gt; &lt;param-value&gt;3628800&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AccessControlAllowHeaders&lt;/param-name&gt; &lt;param-value&gt;x-requested-with&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CrossOrigin&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 3.就可以在WebContent目录下新建一个jsp页面，用来测试页面是否可以被跨域请求，jsp代码如下：123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;tomcat 2.0&lt;/h1&gt;&lt;/body&gt;&lt;html&gt; 4.简单说一下跨域测试，用google浏览器就可以测试了，因为谷歌浏览器默认用ajax或者iframe加载本地文件也是跨域请求。所以你现在eclipse里面把这个页面项目在server里跑起来，就新建一个页面用ajax加载跑起来之后的网址，如果是就成功咯o(^-^)o","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"eclipse","slug":"eclipse","permalink":"https://yebuq.github.io/tags/eclipse/"},{"name":"跨域","slug":"跨域","permalink":"https://yebuq.github.io/tags/跨域/"}]},{"title":"关于切换选项卡时页面请求在谷歌浏览器下可用，在IE11下假死的问题","date":"2017-02-27T04:01:08.000Z","path":"2017/02/27/关于页面在谷歌浏览器下可用，在IE11下假死的问题/","text":"摘要: 问题大概是这样的：在项目里调兼容的时候遇到的一个莫名的问题，页面在谷歌浏览器下完全没问题，但是在IE11下面测试的时候在第一个选项卡切换到第二个选项卡，这个时候没问题可是再切换到第一个选项卡的时候页面就无响应了。 正文: 问题大概是这样的：在项目里调兼容的时候遇到的一个莫名的问题，页面在谷歌浏览器下完全没问题，但是在IE11下面测试的时候在第一个选项卡切换到第二个选项卡，这个时候没问题可是再切换到第一个选项卡的时候页面就无响应了。 这里是默认打开页面的时候，默认选项卡为：终端动态图 这里是从第一个选项卡切换到第二个选项卡“终端信息列表”的时候： 然后，问题来了，在这个时候再切换回第一个页面的时候就出问题了，页面无响应，一直停留在第二个选项卡。下面是部分关键js代码，用的bootstrap框架：第一个选项卡的js： 1234567891011121314151617181920212223242526$(\".details_ap a[href='#tab_topology_detail']\").click(function(ev)&#123; $(this).tab(\"show\"); if(navigator.appName == \"Microsoft Internet Explorer\" &amp;&amp; navigator.appVersion.match(/8./i)==\"8.\")&#123; tab_1 += 1 &#125; if(tab_1 &lt;= 1)&#123; ec_graph = echarts.init(document.getElementById(\"ec_graph\")); &#125; clearInterval(timerWhiteGraph); clearInterval(timerWhiteList); showDetails(graphWhite); timerWhiteGraph = setInterval(function()&#123; var _url = '../../rest/topology/whiteSta?apMac=' + apMac.apMac + '&amp;apMac2=' + apMac.apMac2 + '&amp;apMac5=' + apMac.apMac5; $.get(_url,function(info)&#123; if(info.resultCode == \"0\")&#123; graphWhite = createNode(info); showDetails(graphWhite); &#125; else&#123; alert(\"数据异常代码\" + info.resultCode); &#125; &#125;); &#125;,30000); var oEvent=ev||event; oEvent.preventDefault();&#125;); 这里是第二个选项卡的js： 1234567891011121314151617$(\".details_ap a[href='#tab_table_detail']\").click(function(ev)&#123; $(this).tab(\"show\"); if(tab_2 &lt;= 1)&#123; &#125; if(navigator.appName == \"Microsoft Internet Explorer\" &amp;&amp; navigator.appVersion.match(/8./i)==\"8.\")&#123; tab_2 += 1; &#125; tableInit(tableUrlWhite); clearInterval(timerWhiteGraph); clearInterval(timerWhiteList); timerWhiteList = setInterval(function()&#123; tableInit(tableUrlWhite); &#125;,30000); var oEvent = ev || event; oEvent.preventDefault();&#125;); 各位看出来问题在哪了吗。。。我看了很久实在是找不到问题在哪，后来误打误撞翻到了一片文章（ps;后来找不到了= =）说是$.get的方法在请求数据的时候，浏览器要缓存的，就是这个缓存出了问题，第一个页面默认出来就进行get请求，get请求的响应在IE下默认是可以缓存的(响应应该包含一个到期时间, 或者有一个验证器)，页面刚打开缓存，从第二个选项卡切换回来又缓存，两个同时进行就卡死了。。 解决方案：很简单，就是把get方法改成post就可以了，因为post默认是不会缓存的。 希望此篇日志对大家有帮助o(^▽^)o","tags":[{"name":"前端","slug":"前端","permalink":"https://yebuq.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://yebuq.github.io/tags/js/"},{"name":"兼容","slug":"兼容","permalink":"https://yebuq.github.io/tags/兼容/"}]},{"title":"热烈庆祝耶不q的小窝搭建成功啦~","date":"2017-02-24T03:44:03.000Z","path":"2017/02/24/热烈庆祝耶不q的小窝搭建成功啦/","text":"摘要: 从事行业这么这么长时间以来，一直一直筹划着想有一个自己的部落格，直到今天，这个愿望终于算是实现啦………. 正文: 从事行业这么这么长时间以来，一直一直筹划着想有一个自己的部落格，但是犹豫比较忙（ps:其实大部分原因还是懒啦。。。哈哈哈。。。。），这个夙愿一直没有达成。 但是直到今天，这个愿望终于算是实现啦！经历一天的时间，搭配着github代码仓库，总算是把自己的部落格搭建起来了~~ 初步完成的小窝支持响应式，在pc端和移动端都有很好的体验效果。但是有点不足就是必须ie9以上（终于可以说句：去屎吧ie8！现在不是公司的项目你猜我还理你嘛！？）。 以后会渐渐更新我的小窝，初步计划小窝里会更新一些技术上的问题，到现在累积了一些自认为技术上的亮点跟一些深坑，会慢慢贴到自己的小窝里。 除了技术上的难题，还会更新一些生活上的琐事。嘿嘿嘿嘿。。。。我在想要不要打个码再把这些鸡毛蒜皮的事情更新上来。。 嗯嗯，反正就是这样啦！祝愿我的小窝越来越精彩，越来越被你们关注~啦啦啦~","tags":[{"name":"开篇之作","slug":"开篇之作","permalink":"https://yebuq.github.io/tags/开篇之作/"},{"name":"啦啦啦","slug":"啦啦啦","permalink":"https://yebuq.github.io/tags/啦啦啦/"},{"name":"生活","slug":"生活","permalink":"https://yebuq.github.io/tags/生活/"}]},{"title":"Hello World","date":"2017-02-21T18:01:08.000Z","path":"2017/02/22/hello-world/","text":"It’s feel so good when you give the shit to someone had ever look down upon you o(^-^)o","tags":[{"name":"开篇之作","slug":"开篇之作","permalink":"https://yebuq.github.io/tags/开篇之作/"},{"name":"啦啦啦","slug":"啦啦啦","permalink":"https://yebuq.github.io/tags/啦啦啦/"}]}]